{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_26-9beefa37a4404a4276d72c8f47b91d4eb77784cf",
  "solcVersion": "0.8.26",
  "solcLongVersion": "0.8.26+commit.8a97fa7a",
  "userSourceNameMap": {
    "contracts/AttributeContract.sol": "project/contracts/AttributeContract.sol",
    "contracts/DroneContract.sol": "project/contracts/DroneContract.sol",
    "contracts/LoggingContract.sol": "project/contracts/LoggingContract.sol",
    "contracts/PDP.sol": "project/contracts/PDP.sol",
    "contracts/PolicyContract.sol": "project/contracts/PolicyContract.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/AttributeContract.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract AttributeContract {\r\n    struct Attribute {\r\n        uint id;\r\n        string name;\r\n        uint[] value;\r\n        bool exists;\r\n    }\r\n\r\n    Attribute[] public attributes;\r\n    uint public nextId;\r\n\r\n    event AttributeCreated(uint indexed id, string name, uint[] value);\r\n    event AttributeUpdated(uint indexed id, string name, uint[] value);\r\n    event AttributeDeleted(uint indexed id);\r\n\r\n    function createAttribute(string memory _name, uint[] memory _value) public {\r\n        attributes.push(Attribute(nextId, _name, _value, true));\r\n        emit AttributeCreated(nextId, _name, _value);\r\n        nextId++;\r\n    }\r\n\r\n    function getAttribute(uint _id) public view returns (Attribute memory) {\r\n        require(_id < nextId && attributes[_id].exists, \"Attribute does not exist\");\r\n        return attributes[_id];\r\n    }\r\n\r\n    function updateAttribute(uint _id, string memory _name, uint[] memory _value) public {\r\n        require(_id < nextId && attributes[_id].exists, \"Attribute does not exist\");\r\n        Attribute storage attribute = attributes[_id];\r\n        attribute.name = _name;\r\n        attribute.value = _value;\r\n        emit AttributeUpdated(_id, _name, _value);\r\n    }\r\n\r\n    function deleteAttribute(uint _id) public {\r\n        require(_id < nextId && attributes[_id].exists, \"Attribute does not exist\");\r\n        attributes[_id].exists = false; // Mark as deleted\r\n        emit AttributeDeleted(_id);\r\n    }\r\n\r\n    function getAttributes() public view returns (Attribute[] memory) {\r\n        uint count = 0;\r\n        for (uint i = 0; i < attributes.length; i++) {\r\n            if (attributes[i].exists) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        Attribute[] memory result = new Attribute[](count);\r\n        uint index = 0;\r\n        for (uint i = 0; i < attributes.length; i++) {\r\n            if (attributes[i].exists) {\r\n                result[index] = attributes[i];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function getAttributesByName(string memory _name) public view returns (Attribute[] memory) {\r\n        uint count = 0;\r\n        for (uint i = 0; i < attributes.length; i++) {\r\n            if (attributes[i].exists && compareStrings(attributes[i].name, _name)) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        Attribute[] memory result = new Attribute[](count);\r\n        uint index = 0;\r\n        for (uint i = 0; i < attributes.length; i++) {\r\n            if (attributes[i].exists && compareStrings(attributes[i].name, _name)) {\r\n                result[index] = attributes[i];\r\n                index++;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\r\n        return (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b)));\r\n    }\r\n}\r\n"
      },
      "project/contracts/DroneContract.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract DroneContract {\r\n    struct Drone {\r\n        uint id;\r\n        string model_type;\r\n        int zone;\r\n        bool exists;\r\n    }\r\n\r\n    Drone[] public drones;\r\n    uint public nextId;\r\n\r\n    event DroneCreated(uint indexed id, string model_type, int zone);\r\n    event DroneUpdated(uint indexed id, string model_type, int zone);\r\n    event DroneDeleted(uint indexed id);\r\n\r\n    function createDrone(string memory _model_type, int _zone) public  {\r\n        for (uint i = 0; i < drones.length; i++) {\r\n            if (drones[i].exists && keccak256(abi.encodePacked(drones[i].model_type)) == keccak256(abi.encodePacked(_model_type)) && keccak256(abi.encodePacked(_model_type)) == keccak256(abi.encodePacked(\"Terminal\")) && drones[i].zone == _zone) {\r\n                revert(\"A terminal drone already exists in this zone.\");\r\n            }\r\n        }\r\n\r\n        drones.push(Drone(nextId, _model_type, _zone, true));\r\n        emit DroneCreated(nextId, _model_type, _zone);\r\n        nextId ++;\r\n    }\r\n\r\n    // PIP\r\n    function getDrone(uint _id) public view returns (Drone memory) {\r\n        require(_id < nextId && drones[_id].exists, \"Drone does not exist\");\r\n        return (drones[_id]);\r\n    }\r\n\r\n    function updateDrone(uint _id, string memory _model_type, int _zone) public {\r\n        require(_id < nextId && drones[_id].exists, \"Drone does not exist\");\r\n        Drone storage drone = drones[_id];\r\n        drone.model_type = _model_type;\r\n        drone.zone = _zone;\r\n        emit DroneUpdated(_id, _model_type, _zone);\r\n    }\r\n\r\n    function deleteDrone(uint _id) public {\r\n        require(_id < nextId && drones[_id].exists, \"Drone does not exist\");\r\n        drones[_id].exists = false;\r\n        emit DroneDeleted(_id);\r\n    }\r\n\r\n    function getDrones() public view returns (Drone[] memory) {\r\n        uint count = 0;\r\n        for (uint i = 0; i < drones.length; i++) {\r\n            if (drones[i].exists) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        Drone[] memory result = new Drone[](count);\r\n        uint index = 0;\r\n        for (uint i = 0; i < drones.length; i++) {\r\n            if (drones[i].exists) {\r\n                result[index] = drones[i];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function getDronesByZone(int _zone) public view returns (Drone[] memory) {\r\n        uint count = 0;\r\n        for (uint i = 0; i < drones.length; i++) {\r\n            if (drones[i].exists && drones[i].zone == _zone) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        Drone[] memory result = new Drone[](count);\r\n        uint index = 0;\r\n        for (uint i = 0; i < drones.length; i++) {\r\n            if (drones[i].exists && drones[i].zone == _zone) {\r\n                result[index] = drones[i];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"
      },
      "project/contracts/LoggingContract.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.26;\r\n\r\ncontract LoggingContract {\r\n    struct LogEntry {\r\n        address user;\r\n        string action;\r\n        string data;\r\n    }\r\n\r\n    LogEntry[] public logs;\r\n    uint constant SAUDI_ARABIA_OFFSET = 3 * 60 * 60;\r\n    event ActionLogged(address indexed user, string action, string data);\r\n\r\n    function logAction(string memory action, string memory data) public {\r\n\r\n        logs.push(LogEntry(msg.sender, action, data));\r\n        emit ActionLogged(msg.sender, action, data);\r\n    }\r\n\r\n    function getLogs() public view returns (LogEntry[] memory) {\r\n        return logs;\r\n    }\r\n}\r\n"
      },
      "project/contracts/PDP.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.26;\r\n\r\nimport \"./LoggingContract.sol\";\r\nimport \"./PolicyContract.sol\";\r\nimport \"./DroneContract.sol\";\r\n\r\ncontract PDP {\r\n    LoggingContract public logger;\r\n    PolicyContract public policy;\r\n    DroneContract public drone;\r\n\r\n    uint constant SAUDI_ARABIA_OFFSET = 3 * 60 * 60;\r\n\r\n    constructor(address _policyAddress, address _droneAddress, address _loggerAddress) {\r\n        policy = PolicyContract(_policyAddress);\r\n        drone = DroneContract(_droneAddress);\r\n        logger = LoggingContract(_loggerAddress);\r\n    }\r\n\r\n    event AccessEvaluated(uint indexed entityId, bool accessGranted);\r\n\r\n    function level0EvaluateAccess(uint _id, string memory _model_type, int _zone, string memory _startTime, string memory _endTime, bool _accessGranted) public returns (bool) {\r\n        uint currentTime = block.timestamp + SAUDI_ARABIA_OFFSET;\r\n\r\n        string memory formattedTime = formatTime(currentTime);\r\n\r\n        string memory action = \"Access Request\";\r\n        string memory data = string(abi.encodePacked(\r\n            \"Level: 0, Drone: \", uint2str(_id),\r\n            \", Time: \", formattedTime\r\n        ));\r\n        logger.logAction(action, data);\r\n\r\n        action = \"PIP\";\r\n        data = string(abi.encodePacked(\r\n            \"Drone Id: \", uint2str(_id),\r\n            \", ModelType: \", _model_type,\r\n            \", Zone: \", int2str(_zone)\r\n        ));\r\n        logger.logAction(action, data);\r\n\r\n        action = \"PRP\";\r\n        data = string(abi.encodePacked(\r\n            \"Zone: \", int2str(_zone),\r\n            \", StartTime: \", _startTime,\r\n            \", EndTime: \", _endTime\r\n        ));\r\n        logger.logAction(action, data);\r\n\r\n        action = \"PDP\";\r\n        data = string(abi.encodePacked(\r\n            \"Decision: \", _accessGranted ? \"Passed\" : \"Denied\"\r\n        ));\r\n        logger.logAction(action, data);\r\n\r\n        bool accessGranted = _accessGranted;\r\n        emit AccessEvaluated(_id, accessGranted);\r\n        return accessGranted;\r\n\r\n    }\r\n\r\n    function level1EvaluateAccess(uint _id, string memory _model_type, int _zone, string memory _startTime, string memory _endTime) public returns (bool) {\r\n        uint currentTime = block.timestamp + SAUDI_ARABIA_OFFSET;\r\n        uint currentSeconds = currentTime % (24 * 60 * 60);\r\n\r\n        bool accessGranted = false;\r\n\r\n        string memory formattedTime = formatTime(currentTime);\r\n\r\n        if (compareTimes(currentSeconds, _startTime, _endTime)) {\r\n            accessGranted = true;\r\n        }\r\n\r\n        string memory action = \"Access Request\";\r\n        string memory data = string(abi.encodePacked(\r\n            \"Level: 1, Drone: \", uint2str(_id),\r\n            \", Time: \", formattedTime\r\n        ));\r\n        logger.logAction(action, data);\r\n\r\n        action = \"PIP\";\r\n        data = string(abi.encodePacked(\r\n            \"Drone Id: \", uint2str(_id),\r\n            \", ModelType: \", _model_type,\r\n            \", Zone: \", int2str(_zone)\r\n        ));\r\n        logger.logAction(action, data);\r\n\r\n        action = \"PRP\";\r\n        data = string(abi.encodePacked(\r\n            \"Zone: \", int2str(_zone),\r\n            \", StartTime: \", _startTime,\r\n            \", EndTime: \", _endTime\r\n        ));\r\n        logger.logAction(action, data);\r\n\r\n        action = \"PDP\";\r\n        data = string(abi.encodePacked(\r\n            \"Decision: \", accessGranted ? \"Passed\" : \"Denied\"\r\n        ));\r\n        logger.logAction(action, data);\r\n\r\n        emit AccessEvaluated(_id, accessGranted);\r\n        return accessGranted;\r\n    }\r\n\r\n    function level2EvaluateAccess(uint _id, string memory _model_type, int _zone) public returns (bool) {\r\n        uint currentTime = block.timestamp + SAUDI_ARABIA_OFFSET;\r\n        uint currentSeconds = currentTime % (24 * 60 * 60);\r\n\r\n        bool accessGranted = false;\r\n        PolicyContract.Policy memory policyDetails = policy.getPolicyByZone(_zone);\r\n\r\n        string memory formattedTime = formatTime(currentTime);\r\n\r\n        if (compareTimes(currentSeconds, policyDetails.startTime, policyDetails.endTime)) {\r\n            accessGranted = true;\r\n        }\r\n\r\n        string memory action = \"Access Request\";\r\n        string memory data = string(abi.encodePacked(\r\n            \"Level: 2, Drone: \", uint2str(_id),\r\n            \", Time: \", formattedTime\r\n        ));\r\n        logger.logAction(action, data);\r\n\r\n        action = \"PIP\";\r\n        data = string(abi.encodePacked(\r\n            \"Drone Id: \", uint2str(_id),\r\n            \", ModelType: \", _model_type,\r\n            \", Zone: \", int2str(_zone)\r\n        ));\r\n        logger.logAction(action, data);\r\n\r\n        action = \"PRP\";\r\n        data = string(abi.encodePacked(\r\n            \"Zone: \", int2str(policyDetails.zone),\r\n            \", StartTime: \", policyDetails.startTime,\r\n            \", EndTime: \", policyDetails.endTime\r\n        ));\r\n        logger.logAction(action, data);\r\n\r\n        action = \"PDP\";\r\n        data = string(abi.encodePacked(\r\n            \"Decision: \", accessGranted ? \"Passed\" : \"Denied\"\r\n        ));\r\n        logger.logAction(action, data);\r\n\r\n        emit AccessEvaluated(_id, accessGranted);\r\n        return accessGranted;\r\n    }\r\n\r\n    function level3EvaluateAccess(uint _entityId) public returns (bool) {\r\n        uint currentTime = block.timestamp + SAUDI_ARABIA_OFFSET;\r\n        uint currentSeconds = currentTime % (24 * 60 * 60);\r\n\r\n        bool accessGranted = false;\r\n        DroneContract.Drone memory droneDetails = drone.getDrone(_entityId);\r\n        PolicyContract.Policy memory policyDetails = policy.getPolicyByZone(droneDetails.zone);\r\n\r\n        string memory formattedTime = formatTime(currentTime);\r\n\r\n        if (compareTimes(currentSeconds, policyDetails.startTime, policyDetails.endTime)) {\r\n            accessGranted = true;\r\n        }\r\n\r\n        string memory action = \"Access Request\";\r\n        string memory data = string(abi.encodePacked(\r\n            \"Level: 3, Drone: \", uint2str(_entityId),\r\n            \", Time: \", formattedTime\r\n        ));\r\n        logger.logAction(action, data);\r\n\r\n        action = \"PIP\";\r\n        data = string(abi.encodePacked(\r\n            \"Drone Id: \", uint2str(_entityId),\r\n            \", ModelType: \", droneDetails.model_type,\r\n            \", Zone: \", int2str(droneDetails.zone)\r\n        ));\r\n        logger.logAction(action, data);\r\n\r\n        action = \"PRP\";\r\n        data = string(abi.encodePacked(\r\n            \"Zone: \", int2str(policyDetails.zone),\r\n            \", StartTime: \", policyDetails.startTime,\r\n            \", EndTime: \", policyDetails.endTime\r\n        ));\r\n        logger.logAction(action, data);\r\n\r\n        action = \"PDP\";\r\n        data = string(abi.encodePacked(\r\n            \"Decision: \", accessGranted ? \"Passed\" : \"Denied\"\r\n        ));\r\n        logger.logAction(action, data);\r\n\r\n        emit AccessEvaluated(_entityId, accessGranted);\r\n        return accessGranted;\r\n    }\r\n\r\n    function formatTime(uint timestamp) internal pure returns (string memory) {\r\n        uint hour = (timestamp / 60 / 60) % 24;\r\n        uint minute = (timestamp / 60) % 60;\r\n        uint second = timestamp % 60;\r\n\r\n        string memory hourStr = _padZero(hour);\r\n        string memory minuteStr = _padZero(minute);\r\n        string memory secondStr = _padZero(second);\r\n\r\n        return string(abi.encodePacked(hourStr, \":\", minuteStr, \":\", secondStr));\r\n    }\r\n\r\n    function _padZero(uint num) internal pure returns (string memory) {\r\n        if (num < 10) {\r\n            return string(abi.encodePacked(\"0\", uint2str(num)));\r\n        }\r\n        return uint2str(num);\r\n    }\r\n\r\n    function parseTimeString(string memory timeString) internal pure returns (uint) {\r\n        bytes memory b = bytes(timeString);\r\n        require(b.length == 8, \"invalid time format\");\r\n\r\n        uint hr = (uint(uint8(b[0])) - 48) * 10 + (uint(uint8(b[1])) - 48);\r\n        uint min = (uint(uint8(b[3])) - 48) * 10 + (uint(uint8(b[4])) - 48);\r\n        uint sec = (uint(uint8(b[6])) - 48) * 10 + (uint(uint8(b[7])) - 48);\r\n\r\n        require(hr < 24 && min < 60 && sec < 60, \"Invalid time value\");\r\n\r\n        return hr * 3600 + min * 60 + sec;\r\n    }\r\n\r\n    function compareTimes(uint currentSeconds, string memory startTime, string memory endTime) internal pure returns (bool) {\r\n        uint startSeconds = parseTimeString(startTime);\r\n        uint endSeconds = parseTimeString(endTime);\r\n\r\n        if (startSeconds <= endSeconds) {\r\n            return (currentSeconds >= startSeconds && currentSeconds <= endSeconds);\r\n        } else {\r\n            return ((currentSeconds > startSeconds && currentSeconds <= 86400) || (currentSeconds >= 0 && currentSeconds <= endSeconds));\r\n        }\r\n    }\r\n\r\n    function uint2str(uint _i) internal pure returns (string memory) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        while (_i != 0) {\r\n            k = k - 1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function int2str(int _i) internal pure returns (string memory) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        bool negative = _i < 0;\r\n        uint j = uint(negative ? -_i : _i);\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        if (negative) len++;\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        j = uint(negative ? -_i : _i);\r\n        while (j != 0) {\r\n            k = k - 1;\r\n            uint8 temp = (48 + uint8(j - j / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            j /= 10;\r\n        }\r\n        if (negative) {\r\n            bstr[0] = '-';\r\n        }\r\n        return string(bstr);\r\n    }\r\n}\r\n"
      },
      "project/contracts/PolicyContract.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.26;\r\n\r\ncontract PolicyContract {\r\n    struct Policy {\r\n        uint id;\r\n        int zone;\r\n        string startTime;\r\n        string endTime;\r\n        bool exists;\r\n    }\r\n\r\n    Policy[] public policies;\r\n    uint public nextId;\r\n\r\n    event PolicyCreated(uint indexed id, int zone, string startTime, string endTime);\r\n    event PolicyUpdated(uint indexed id, int zone, string startTime, string endTime);\r\n    event PolicyDeleted(uint indexed id);\r\n\r\n    function createPolicy(int _zone, string memory _startTime, string memory _endTime) public {\r\n        policies.push(Policy(nextId, _zone, _startTime, _endTime, true));\r\n        emit PolicyCreated(nextId, _zone, _startTime, _endTime);\r\n        nextId ++;\r\n    }\r\n\r\n    function getPolicy(uint _id) public view returns (Policy memory) {\r\n        require(_id < nextId && policies[_id].exists, \"Policy does not exist\");\r\n        return policies[_id];\r\n    }\r\n\r\n    function updatePolicy(uint _id, int _zone, string memory _startTime, string memory _endTime) public {\r\n        require(_id < nextId && policies[_id].exists, \"Policy does not exist\");\r\n        Policy storage policy = policies[_id];\r\n        policy.zone = _zone;\r\n        policy.startTime = _startTime;\r\n        policy.endTime = _endTime;\r\n        emit PolicyUpdated(_id, _zone, _startTime, _endTime);\r\n    }\r\n\r\n    function deletePolicy(uint _id) public {\r\n        require(_id < nextId && policies[_id].exists, \"Policy does not exist\");\r\n        policies[_id].exists = false;\r\n        emit PolicyDeleted(_id);\r\n    }\r\n\r\n    function getPolicies() public view returns (Policy[] memory) {\r\n        uint count = 0;\r\n        for (uint i = 0; i < policies.length; i++) {\r\n            if (policies[i].exists) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        Policy[] memory result = new Policy[](count);\r\n        uint index = 0;\r\n        for (uint i = 0; i < policies.length; i++) {\r\n            if (policies[i].exists) {\r\n                result[index] = policies[i];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    //PRP\r\n    function getPolicyByZone(int _zone) public view returns (Policy memory) {\r\n\r\n        for (uint i = 0; i < policies.length; i ++) {\r\n            if (policies[i].zone == _zone && policies[i].exists) {\r\n                return policies[i];\r\n            }\r\n        }\r\n        revert(\"Policy not found\");\r\n    }\r\n}\r\n"
      }
    }
  }
}